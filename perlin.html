<!-- THIS CODE IS FOR REFEENCE IN IMPLEMENTING A PERLIN NOISE FUNCTION -->
<!-- SOURCE: http://stackoverflow.com/questions/8405526/javascript-simplex-perlin-noise/8405817#8405817 -->
<!-- RAW: http://jsfiddle.net/loktar/4qAxZ/ -->
<!-- SEE ALSO: https://github.com/loktar00/Javascript-Canvas-Terrain-Generator -->
<!-- AND: https://gist.github.com/banksean/304522 -->
<!-- AND: http://freespace.virgin.net/hugo.elias/models/m_perlin.htm -->
<!-- AND: http://gamedev.stackexchange.com/questions/18330/understanding-perlin-noise -->

<html>
	<head>

		<script type="text/javascript" src="vis.js"></script>

		<style>

			canvas {
				display: block;
				margin: auto;
			}

		</style>

	</head>
	<body>

		<canvas id="canvas"></canvas>

	</body>

	<script>

		//Returns a positive int, up to 256, 
		function luminosity(d) {
		    return Math.round( Math.min( Math.max(d, 0), maxXY - 1) );
		}

		//translates (x,y) coords into a position in a linear array of int
		function findPixelData(x, y) {
		    return (y * maxXY + x) * 4;
		}

		//Calls a provided function over a 256x256 element array.
		function cycleThrough(d) {
		    for (y = maxXY; y; y--) {
		        for (x = maxXY; x; x--) {
		            d(x, y);
		        }
		    }
		}

		function L(_ctx, mouseX, mouseY, deltaHypotenuse) {
		    var canvasData = _ctx.getImageData(0, 0, maxXY, maxXY);
		    //var pixelData  = canvasData.data;
		    // need a new copy
		    var pixelData  = _ctx.getImageData(0, 0, maxXY, maxXY).data;

		    // loop through all 256 pixels
		    cycleThrough(function (x, y) {

		        //Find the pixelData value for each pixel surrounding the target pixel
		        var pixelData1 = pixelData[findPixelData(x, y + 1)];
		        var pixelData2 = pixelData[findPixelData(x, y - 1)];
		        var pixelData3 = pixelData[findPixelData(x + 1, y)];
		        var pixelData4 = pixelData[findPixelData(x - 1, y)];

		        /*
		            Set the intensity of a point to the luminosity of
		            a value from the array where we generated the hypotenuses (see code below).
		            
		            The value we're looking for is calculated based on mouse movement, and difference between pixels.
		        */
		        var intensity = luminosity(
		            deltaHypotenuse[
		                  luminosity( pixelData1 - pixelData2 - y + mouseY) * maxXY 
		                + luminosity( pixelData3 - pixelData4 - x + mouseX)
		            ]
		        );

		        //This sets RGB of pixel data to the value of intensity.
		        for (i = 3; i--;) {
		        	// loop condition evaluates to 3, 2, 1, but the value of i once inside the loop is 2, 1, 0
		            canvasData.data[findPixelData(x, y) + i] = intensity;
		        }

		        //This paints the whole background's channel, makes it black.
		        canvasData.data[findPixelData(x, y) + 3] = maxXY - 1;
		    });

		    _ctx.putImageData(canvasData, maxXY, 0);
		}

		var maxXY = 256;
		var originXY = maxXY / 2;

		//Generate an array with values that show the distance between (x,y) point and every canvas point.
		var deltaHypotenuse = [];
		cycleThrough(function (x, y) {
		    //Generates a value from -1 to +1 represeting location from point (128,128).
		    V = (x - originXY) / originXY;
		    W = (y - originXY) / originXY;
		    
		    //Assigns a value between 0 and 255 to a pseudo 2D array, where the value is the length of a hypotenuse to X,Y
		    deltaHypotenuse[y * maxXY + x] = Math.max(0, 1 - Math.sqrt(V * V + W * W)) * 256;
		});

		var mouseX = mouseY = 0;
		var canvas = document.getElementById("canvas");

		canvas.width = maxXY * 2;
		canvas.height = maxXY;

		var ctx = canvas.getContext("2d");
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		document.onmousemove = function (d) {
		    mouseX = d.clientX;
		    mouseY = d.clientY;
		};

		//L(ctx, 32, 128, deltaHypotenuse);
		setInterval(function(){
			L(ctx, mouseX, mouseY, deltaHypotenuse);
		}, 50);


		// Setup the map array for use
		var map = [],
		    mapDimension = maxXY,
		    roughness = 30,
		    unitSize = 1;     

		for(var x = 0; x < mapDimension+1; x++){
	        map[x] = []; 
		    for(var y = 0; y < mapDimension+1; y++){
		    	map[x][y] = 0;
		    } 
		}

		startDisplacement();

		// Starts off the map generation, seeds the first 4 corners
		function startDisplacement() {
		    var tr, tl, t, br, bl, b, r, l, center;
		    
		    // top left
		    map[0][0] = Math.random();
		    tl = map[0][0];
		    
		    // bottom left
		    map[0][mapDimension] = Math.random();
		    bl = map[0][mapDimension];
		    
		    // top right
		    map[mapDimension][0] = Math.random();
		    tr = map[mapDimension][0];
		    
		    // bottom right
		    map[mapDimension][mapDimension] = Math.random();
		    br = map[mapDimension][mapDimension]
		    
		    // Center
		    map[mapDimension / 2][mapDimension / 2] = map[0][0] + map[0][mapDimension] + map[mapDimension][0] + map[mapDimension][mapDimension] / 4;
		    map[mapDimension / 2][mapDimension / 2] = normalize(map[mapDimension / 2][mapDimension / 2]);
		    center = map[mapDimension / 2][mapDimension / 2];
		    
		    map[mapDimension / 2][mapDimension] = bl + br + center / 3;
		    map[mapDimension / 2][0] = tl + tr + center / 3;
		    map[mapDimension][mapDimension / 2] = tr + br + center / 3;
		    map[0][mapDimension / 2] = tl + bl + center / 3;
		    
		    // Call displacment 
		    midpointDisplacment(mapDimension);
		    
		    // Draw everything after the terrain vals are generated
		    drawMap(mapDimension, "canvas", map);    
		}

		// Workhorse of the terrain generation.
	    function midpointDisplacment(dimension){
	        var newDimension = dimension / 2, 
	            top, topRight, topLeft, bottom, bottomLeft, bottomRight, right, left, center,
	            i, j;
	        
	        if (newDimension > unitSize){
	            for(i = newDimension; i <= mapDimension; i += newDimension){
	                for(j = newDimension; j <= mapDimension; j += newDimension){
	                    x = i - (newDimension / 2);
	                    y = j - (newDimension / 2);
	                    
	                    topLeft = map[i - newDimension][j - newDimension]; 
	                    topRight = map[i][j - newDimension];
	                    bottomLeft = map[i - newDimension][j];
	                    bottomRight = map[i][j];
	                    
	                    // Center                
	                    map[x][y] = (topLeft + topRight + bottomLeft + bottomRight) / 4 + displace(dimension);
	                    map[x][y] = normalize(map[x][y]);
	                    center = map[x][y];    
	                    
	                    // Top
	                    if(j - (newDimension * 2) + (newDimension / 2) > 0){
	                        map[x][j - newDimension] = (topLeft + topRight + center + map[x][j - dimension + (newDimension / 2)]) / 4 + displace(dimension);;
	                    }else{
	                        map[x][j - newDimension] = (topLeft + topRight + center) / 3+ displace(dimension);
	                    }
	                    
	                    map[x][j - newDimension] = normalize(map[x][j - newDimension]);
	            
	                    // Bottom
	                    if(j + (newDimension / 2) < mapDimension){
	                        map[x][j] = (bottomLeft + bottomRight + center + map[x][j + (newDimension / 2)]) / 4+ displace(dimension);
	                    }else{
	                        map[x][j] = (bottomLeft + bottomRight + center) / 3+ displace(dimension);
	                    }
	                    
	                    map[x][j] = normalize(map[x][j]);

	                    
	                    //Right
	                    if(i + (newDimension / 2) < mapDimension){
	                        map[i][y] = (topRight + bottomRight + center + map[i + (newDimension / 2)][y]) / 4+ displace(dimension);
	                    }else{
	                        map[i][y] = (topRight + bottomRight + center) / 3+ displace(dimension);
	                    }
	                    
	                    map[i][y] = normalize(map[i][y]);
	                    
	                    // Left
	                    if(i - (newDimension * 2) + (newDimension / 2) > 0){
	                        map[i - newDimension][y] = (topLeft + bottomLeft + center + map[i - dimension + (newDimension / 2)][y]) / 4 + displace(dimension);;
	                    }else{
	                        map[i - newDimension][y] = (topLeft + bottomLeft + center) / 3+ displace(dimension);
	                    }
	                    
	                    map[i - newDimension][y] = normalize(map[i - newDimension][y]);
	                }
	            }
	            midpointDisplacment(newDimension);
	        }
	    }


		// Draw the map
	    function drawMap(size, canvasId, mapData){
	        var canvas = document.getElementById(canvasId),
	        ctx = canvas.getContext("2d"),
	        //canvasData = ctx.getImageData(0, 0, mapDimension, mapDimension),
	        x = 0,
	        y = 0,
	        //r = 0, g = 0, b = 0, gamma = 500,
	        colorFill = 0;
	        
	        for(x = 0; x <= size; x += unitSize){
	            for(y = 0; y <= size; y += unitSize){
	                colorFill = Math.floor(map[x][y] * 250);
	                ctx.fillStyle = "rgb(" + colorFill + "," +  colorFill + "," + colorFill +")";
	                ctx.fillRect (x, y, unitSize, unitSize);
	            }
	        }
	    }

		// Normalize the value to make sure its within bounds
	    function normalize(value){
	        return value < 0 ? 0 : value > 1 ? 1 : value;
	    }

		// Random function to offset the center
	    function displace(num){
	        var max = num / (mapDimension + mapDimension) * roughness;       
	        return (Math.random(1.0)- 0.5) * max;  
	    }

	</script>
</html>